package me.samcefalo.sistemaiadbackend.services;import me.samcefalo.sistemaiadbackend.models.User;import me.samcefalo.sistemaiadbackend.models.enums.UserRole;import me.samcefalo.sistemaiadbackend.repositories.UserRepository;import me.samcefalo.sistemaiadbackend.services.exceptions.AuthorizationException;import me.samcefalo.sistemaiadbackend.services.exceptions.ObjectNotFoundException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Sort;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import java.util.List;@Servicepublic class UserService {    @Autowired    private UserSecurityService userSecurityService;    @Autowired    private UserRepository userRepository;    @Autowired    private BCryptPasswordEncoder bCryptPasswordEncoder;    @Autowired    private AcaoService acaoService;    @Autowired    private AtletaService atletaService;    @Autowired    private JogoService jogoService;    @Autowired    private EquipeService equipeService;    public User find(int id) {        if (!userSecurityService.isAuth(id)) {            throw new AuthorizationException("Acesso negado.");        }        return userRepository.findById(id).orElseThrow(                () -> new ObjectNotFoundException("Objeto não encontrado. ID: " + id + ", Tipo: " + User.class.getSimpleName()));    }    public User findByEmail(String email) {        if (!userSecurityService.isAuth(email)) {            throw new AuthorizationException("Acesso negado.");        }        return userRepository.findByEmail(email).orElseThrow(                () -> new ObjectNotFoundException("Objeto não encontrado. Email: " + email + ", Tipo: " + User.class.getSimpleName()));    }    public User insert(User user) {        if (!userSecurityService.isAdmin() && user.getUserRolesEnum().contains(UserRole.ADMIN)) {            throw new AuthorizationException("Acesso negado.");        }        user.addRole(UserRole.DEFAULT);        user.setSenha(bCryptPasswordEncoder.encode(user.getSenha()));        return userRepository.save(user);    }    public User update(User user) {        User userDB = find(user.getId());        if (!userSecurityService.isAuth(userDB.getId())) {            throw new AuthorizationException("Acesso negado.");        }        updateData(userDB, user);        return userRepository.save(userDB);    }    private void updateData(User userDB, User user) {        userDB.setNome(user.getNome());        userDB.setSenha(bCryptPasswordEncoder.encode(user.getSenha()));        userDB.setUserRoles(user.getUserRoles());    }    public void delete(int id) {        User user = find(id);        delete(user);    }    private void delete(User user) {        acaoService.findAllByUser(user)                .stream().forEach(acao -> acaoService.delete(acao.getId()));        jogoService.findAllByUser(user)                .stream().forEach(jogo -> jogoService.delete(jogo.getId()));        atletaService.findAllByUser(user)                .stream().forEach(atleta -> atletaService.delete(atleta.getId()));        equipeService.findAllByUser(user)                .stream().forEach(equipe -> equipeService.delete(equipe.getId()));        userRepository.delete(user);    }    @Transactional(readOnly = true)    public Page<User> findPage(int page, int linesPerPage, String orderBy, String direction) {        PageRequest pageRequest = PageRequest.of(page, linesPerPage,                Sort.Direction.valueOf(direction.toUpperCase()), orderBy);        return userRepository.findAll(pageRequest);    }    @Transactional(readOnly = true)    public List<User> findAll() {        return userRepository.findAll();    }}